<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/01/21/%E8%AE%A1%E7%BD%91%E2%80%94%E2%80%94IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87/"/>
    <url>/2022/01/21/%E8%AE%A1%E7%BD%91%E2%80%94%E2%80%94IP%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%88%86%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络——IP数据报分片"><a href="#计算机网络——IP数据报分片" class="headerlink" title="计算机网络——IP数据报分片"></a>计算机网络——IP数据报分片</h1><p><strong>例</strong>：一个数据报数据部分为3800字节，规定分片长度不超过1420字节，首部20字节，每个分片数据部分不超过1400字节（MTU为最大传输单元，包括首部和数据部分）</p><blockquote><p><strong>知识提炼</strong>：</p><p>MF=1表示后面“还有分片”，MF=0表示这是若干数据报片中的最后一个</p><p>DF=0时才允许分片</p><p>片偏移：起始数据/8</p></blockquote><table><thead><tr><th>数据报分片</th><th>总长度</th><th>MF位</th><th>DF位</th><th>片偏移字段</th></tr></thead><tbody><tr><td>原始数据报</td><td>3820</td><td>0</td><td>0</td><td>0</td></tr><tr><td>数据报片1</td><td>1420</td><td>1</td><td>0</td><td>0</td></tr><tr><td>数据报片2</td><td>1420</td><td>1</td><td>0</td><td>175</td></tr><tr><td>数据报片3</td><td>1020</td><td>0</td><td>0</td><td>350</td></tr></tbody></table><p><img src="https://hyx-pic.oss-cn-beijing.aliyuncs.com/img/60ab9623a6d90fb3ec836ad322bb8bfd.png" alt="image-20211221220913943"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/01/21/%E8%AE%A1%E7%BD%91%E2%80%94%E2%80%94%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E4%BB%A5%E5%8F%8A%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0/"/>
    <url>/2022/01/21/%E8%AE%A1%E7%BD%91%E2%80%94%E2%80%94%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E4%BB%A5%E5%8F%8A%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络——拥塞避免以及快速重传"><a href="#计算机网络——拥塞避免以及快速重传" class="headerlink" title="计算机网络——拥塞避免以及快速重传"></a>计算机网络——拥塞避免以及快速重传</h1><p>说明：部分图源自B站—计算机网络微课堂，侵删<br><img src="https://hyx-pic.oss-cn-beijing.aliyuncs.com/img/015b94005d6b0e23f32c5c20f7a58af5.png" alt="image-20211221221548155"></p><ul><li>当拥塞窗口 cwnd = 24 时，网络出现了超时（图中的点②），发送方判断为网络拥塞。于是调整门限值ssthresh = cwnd / 2 = 12，同时设置拥塞窗口cwnd = 1，进入慢开始阶段。</li><li>请注意，也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd 值再增大一些（增大3个报文段的长度），即等于新的ssthresh + 3 × MSS（图中的点⑤）。</li></ul><p><img src="https://hyx-pic.oss-cn-beijing.aliyuncs.com/img/be0a09ce3e6224a6e101cfbb223d93e6.png" alt="image-20211221221552090"></p><p> <strong>根据表格画图</strong></p><table><thead><tr><th>1</th><th>2</th><th>4</th><th>8</th><th>16</th><th>17</th><th>18</th><th>19</th><th>20</th><th>21</th><th>22</th><th>23</th><th>24</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>4</td><td>8</td><td>12</td><td>13</td><td>14</td><td>15</td><td>16</td><td>8</td><td>9</td><td>10</td><td>11</td></tr></tbody></table><p>考查形式：慢开始的范围，拥塞避免的范围，门限值是多少</p><p><img src="https://hyx-pic.oss-cn-beijing.aliyuncs.com/img/e83921232520481ad5c1a70d98ee04bf.png" alt="image-20211221221630843"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%92%8C%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/"/>
    <url>/2022/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91%E5%92%8C%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库——并发和故障恢复"><a href="#数据库——并发和故障恢复" class="headerlink" title="数据库——并发和故障恢复"></a>数据库——并发和故障恢复</h1><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li>事务和程序是两个概念<ul><li>在关系数据库中，一个事务可以是一条 SQL 语句，一组SQL 语句或整个程序</li><li>一个程序通常包含多个事务</li></ul></li><li><mark><strong>事务</strong>是恢复和并发控制的<strong>基本单位</strong></mark></li><li>一个事务的执行不能被其他事务干扰<ul><li>一个事务内部的操作及使用的数据对其他并发事务是隔离的</li><li>并发执行的各个事务之间不能互相干扰</li></ul></li><li>事务内部更多的故障是非预期的，是不能由应用程序处理的。<ul><li>运算溢出</li><li>并发事务发生死锁而被选中撤销该事务</li><li>违反了某些完整性限制而被终止等</li></ul></li><li>转储操作与用户事务并发进行</li><li>为保证数据库是可恢复的，登记日志文件时必须遵循两条原则<ul><li>登记的次序严格按并发事务执行的时间次序</li><li>必须先写日志文件，后写数据库<ul><li>写日志文件操作：把表示这个修改的日志记录写到日志文件中</li><li>写数据库操作：把对数据的修改写到数据库中</li></ul></li></ul></li><li>数据库镜像在没有出现故障时可用于并发操作：一个用户对数据加排他锁修改数据，其他用户可以读镜像数据库上的数据，而不必等待该用户释放锁。</li><li>数据库镜像不是对整个数据库进行镜像：在实际应用中用户往往只选择对<strong>关键数据</strong>和<strong>日志文件</strong>镜像</li></ul><h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><h4 id="事务故障的恢复"><a href="#事务故障的恢复" class="headerlink" title="事务故障的恢复"></a>事务故障的恢复</h4><blockquote><p>事务故障：事务在运行至正常终止点前被终止</p></blockquote><p>事务故障的恢复方法：由恢复子系统利用日志文件撤消（ UNDO ）此事务已对数据库进行的修改</p><blockquote><p>事务故障的恢复由系统自动完成，对用户是透明的，不需要用户干预</p></blockquote><p>事务故障的恢复步骤：</p><ol><li>反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。</li><li>对该事务的更新操作执行逆操作。即将日志记录中“更新前的值写入数据库。<ul><li>插入操作，“更新前的值”为空，则相当于做删除操作</li><li>删除操作，“更新后的值”为空，则相当于做插入操作</li><li>若是修改操作，则相当于用修改前值代替修改后值</li></ul></li><li>继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。</li><li>如此处理下去，直至读到此事务的开始标记，事务故障恢复就完成了。</li></ol><h4 id="系统故障的恢复"><a href="#系统故障的恢复" class="headerlink" title="系统故障的恢复"></a>系统故障的恢复</h4><p>系统故障造成数据库不一致状态的原因：</p><ul><li>未完成事务对数据库的更新可能已写入数据库</li><li>已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库</li></ul><p>系统故障的恢复方法：</p><ol><li>Undo故障发生时未完成的事务</li><li>Redo已完成的事务</li></ol><blockquote><p>系统故障的恢复由系统在 重新启动时 自动完成，不需要用户干预</p></blockquote><p>系统故障的恢复步骤：</p><ol><li><p>正向扫描日志文件（即从头扫描日志文件）</p><ul><li>重做 (REDO) 队列 : 在故障发生前已经提交的事务<ul><li>这些事务既有 BEGIN TRANSACTION 记录，也有COMMIT 记录</li></ul></li><li>撤销（队列）：故障发生时尚未完成的事务<ul><li>这些事务只有 BEGIN TRANSACTION 记录，无相应的COMMIT 记录</li></ul></li></ul></li><li><p>对撤销（UNDO）队列事务进行撤销（UNDO）处理</p><ul><li><p>反向扫描日志文件，对每个撤销事务的更新操作执行逆操作</p></li><li><p>即将日志记录中“更新前的值”写入数据库</p></li></ul></li><li><p>对重做（REDO）队列事务进行重做（REDO）处理</p><ul><li><p>正向扫描日志文件，对每个重做事务重新执行登记的操作</p></li><li><p>即将日志记录中“更新后的值”写入数据库</p></li></ul></li></ol><h4 id="介质故障的恢复"><a href="#介质故障的恢复" class="headerlink" title="介质故障的恢复"></a>介质故障的恢复</h4><ol><li>重装数据库</li><li>重做已完成的事务</li></ol><p>介质故障的恢复步骤：</p><ol><li>装入最新的后备数据库副本（离故障发生时刻最近的转储副本），使数据库恢复到最近一次转储时的一致性状态。<ul><li>对于静态转储的数据库副本，装入后数据库即处于一致性状态</li><li>对于动态转储的数据库副本，还须同时装入转储时刻的日志文件副本，利用恢复系统故障的方法（即 REDO+UNDO），才能将数据库恢复到一致性状态。</li></ul></li><li>装入有关的日志文件副本（转储结束时刻的日志文件副本 ) ，重做已完成的事务。<ol><li>首先扫描日志文件，找出故障发生时已提交的事务的标识，将其记入重做队列。</li><li>然后正向扫描日志文件，对重做队列中的所有事务进行重做处理。即将日志记录中“更新后的值”写入数据库。</li></ol></li></ol><p>介质故障的恢复需要数据库管理员介入，数据库管理员的工作是：重装最近转储的数据库副本和有关的各日志文件副本、执行系统提供的恢复命令</p><p>注意：具体的恢复操作仍由数据库管理系统完成</p><h4 id="利用检查点的恢复策略"><a href="#利用检查点的恢复策略" class="headerlink" title="利用检查点的恢复策略"></a>利用检查点的恢复策略</h4><p><img src="https://hyx-pic.oss-cn-beijing.aliyuncs.com/img/2ab26c6862348a4a70a4d5c291378d32.png" alt="image-20211228154653810"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E4%B8%BB%E5%8F%98%E9%87%8F%E3%80%81%E6%8C%87%E7%A4%BA%E5%8F%98%E9%87%8F/"/>
    <url>/2022/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E5%B5%8C%E5%85%A5%E5%BC%8FSQL%E4%B8%BB%E5%8F%98%E9%87%8F%E3%80%81%E6%8C%87%E7%A4%BA%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库——嵌入式SQL主变量、指示变量"><a href="#数据库——嵌入式SQL主变量、指示变量" class="headerlink" title="数据库——嵌入式SQL主变量、指示变量"></a>数据库——嵌入式SQL主变量、指示变量</h1><h3 id="主变量"><a href="#主变量" class="headerlink" title="主变量"></a>主变量</h3><ul><li><p>嵌入式 SQL 语句中可以使用主语言的程序变量来输入或输出数据</p></li><li><p>在 SQL 语句中使用的<strong>主语言程序变量</strong>简称为<strong>主变量（Host Variable）</strong></p></li><li><p>主变量的类型</p><ul><li>输入主变量<ul><li>由应用程序对其赋值， SQL 语句引用</li></ul></li><li>输出主变量<ul><li>由 SQL 语句对其赋值或设置状态信息，返回给应用程序</li></ul></li></ul></li></ul><h3 id="指示变量"><a href="#指示变量" class="headerlink" title="指示变量"></a>指示变量</h3><ul><li>是一个整型变量，用来“指示”所指主变量的值或条件</li><li><strong>一个主变量</strong>可以附带<strong>一个指示变量</strong>（Indicator Variable）</li><li>指示变量的用途<ul><li><strong>指示输入主变量是否为空值</strong></li><li>检测输出变量是否为空值，值是否被截断</li></ul></li></ul><h3 id="在SQL语句中使用主变量和指示变量的方法"><a href="#在SQL语句中使用主变量和指示变量的方法" class="headerlink" title="在SQL语句中使用主变量和指示变量的方法"></a>在SQL语句中使用主变量和指示变量的方法</h3><blockquote><p>在SQL语句<strong>之外</strong>（主语言语句中）使用主变量和指示变量的方法：可以直接引用，不必加冒号</p></blockquote><ul><li><p>说明主变量和指示变量</p></li><li><div class="code-wrapper"><pre><code class="sql">BEGIN DECLARE SECTION......    （说明主变量和指示变量）...END DECLARE SECTION</code></pre></div></li><li><p>使用主变量</p><ul><li><p>说明之后的主变量可以在 SQL 语句中任何一个能够使用表达式的地方出现</p></li><li><p>为了与数据库对象名（表名、视图名、列名等）区别，SQL 语句中的<strong>主变量名</strong> 前要加冒号（:）作为标志</p></li></ul></li><li><p>使用指示变量</p><ul><li><strong>指示变量前也必须加冒号标志</strong></li><li><strong>必须紧跟在所指主变量之后</strong></li></ul></li></ul><img src="https://hyx-pic.oss-cn-beijing.aliyuncs.com/img/image-20211228200012112.png" alt="image-20211228200012112" style="zoom:25%;" /><img src="https://hyx-pic.oss-cn-beijing.aliyuncs.com/img/image-20211228200027327.png" alt="image-20211228200027327" style="zoom:25%;" /><img src="https://hyx-pic.oss-cn-beijing.aliyuncs.com/img/image-20211228200245977.png" alt="image-20211228200245977" style="zoom:25%;" /><img src="https://hyx-pic.oss-cn-beijing.aliyuncs.com/img/image-20211228200258595.png" alt="image-20211228200258595" style="zoom:25%;" />]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%EF%BC%8C%E5%BC%BA%E5%88%B6%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6/"/>
    <url>/2022/01/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E8%87%AA%E4%B8%BB%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%EF%BC%8C%E5%BC%BA%E5%88%B6%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="数据库——自主存取控制，强制存取控制"><a href="#数据库——自主存取控制，强制存取控制" class="headerlink" title="数据库——自主存取控制，强制存取控制"></a>数据库——自主存取控制，强制存取控制</h1><h3 id="自主存取控制"><a href="#自主存取控制" class="headerlink" title="自主存取控制"></a>自主存取控制</h3><blockquote><p>Discretionary Access Control ，简称DAC</p><ul><li>C2级</li><li>用户对不同的数据对象有不同的存取权限</li><li>不同的用户对同一对象也有不同的权限</li><li>用户还可将其拥有的存取权限转授给其他用户</li></ul></blockquote><p><strong>自主存取控制方法</strong></p><ul><li>通过 SQL 的<mark>GRANT </mark>语句和<mark>REVOKE </mark>语句实现</li><li>用户权限组成<ul><li>数据对象</li><li>操作类型</li></ul></li><li>定义用户存取权限：定义用户可以在哪些数据库对象上进行哪些类型的操作</li><li>定义存取权限称为<mark>授权</mark></li></ul><h3 id="强制存取控制"><a href="#强制存取控制" class="headerlink" title="强制存取控制"></a>强制存取控制</h3><blockquote><p>Mandatory Access Control ，简称 MAC</p><ul><li>B1级</li><li>每一个数据对象被标以一定的密级</li><li>每一个用户也被授予某一个级别的许可证</li><li>对于任意一个对象，只有具有合法许可证的用户才可以存取</li></ul></blockquote><p><strong>强制存取控制方法</strong></p><ul><li>保证更高程度的安全性</li><li>用户不能直接感知或进行控制</li><li>适用于对数据有严格而固定密级分类的部门<ul><li>军事部门</li><li>政府部门</li></ul></li><li>在强制存取控制中，数据库管理系统所管理的全部实体被分为主体和客体两大类</li><li><strong>主体</strong>是系统中的活动实体<ul><li>数据库管理系统所管理的实际用户</li><li>代表用户的各进程</li></ul></li><li>客体是系统中的被动实体，受主体操纵<ul><li>文件、基本表、索引、视图</li></ul></li><li>敏感度标记（Label）<ul><li>对于主体和客体， DBMS 为它们每个实例（值）指派一个敏感度标记（ Label）</li><li>敏感度标记分成若干级别<ul><li>绝密（ Top Secret TS）</li><li>机密（ Secret S）</li><li>可信（ Confidential C）</li><li>公开（ Public P）</li><li>TS&gt;=S&gt;=C&gt;=P</li></ul></li></ul></li><li>主体的敏感度标记称为许可证级别（ Clearance Level）</li><li>客体的敏感度标记称为密级（ Classification Level）</li></ul><p><strong>强制存取控制规则</strong></p><ol><li>仅当主体的许可证级别<strong>大于或等于</strong>客体的密级时，该主体才能<strong>读</strong>取相应的客体</li><li>仅当主体的许可证级别<strong>小于或等于</strong>客体的密级时，该主体才能<strong>写</strong>相应的客体</li></ol><ul><li>强制存取控制（ MAC ）是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级标记要求的用户才可以操纵数据。</li><li>实现强制存取控制时<strong>要首先实现自主存取控制</strong><ul><li>原因：较高安全性级别提供的安全保护要包含较低级别的所有保护</li></ul></li><li>自主存取控制与强制存取控制共同构成数据库管理系统的安全机制</li></ul><p><img src="https://hyx-pic.oss-cn-beijing.aliyuncs.com/img/e13845e94bbc964c91921f7ee8b0e507.png" alt="image-20211228100242523"></p><p>==题目5==．什么是数据库中的自主存取控制方法和强制存取控制方法？</p><p>答： </p><p>自主存取控制方法：定义各个用户对不同数据对象的存取权限。当用户对数据库访问时首先检查用户的存取权限。防止不合法用户对数据库的存取。</p><p>强制存取控制方法：每一个数据对象被(强制地)标以一定的密级，每一个用户也被(强制地)授予某一个级别的许可证。系统规定只有具有某一许可证级别的用户才能存取某一个密级的数据对象。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/01/21/test/"/>
    <url>/2022/01/21/test/</url>
    
    <content type="html"><![CDATA[<h2 id="123"><a href="#123" class="headerlink" title="123"></a>123</h2><h2 id="12333"><a href="#12333" class="headerlink" title="12333"></a>12333</h2><h2 id="2324"><a href="#2324" class="headerlink" title="2324"></a>2324</h2>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
